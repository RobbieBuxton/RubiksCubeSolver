\documentclass[8pt]{article}

\usepackage{fullpage}
\usepackage{tikz}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{float}
\usepackage{wrapfig}
\usepackage{titlesec}
\setcounter{secnumdepth}{4}
\graphicspath{ {./pictures/} }
\usepackage[a4paper,bindingoffset=0.2in,%
            left=0.75in,right=1in,top=1in,bottom=1in,%
            footskip=.25in]{geometry}
\usetikzlibrary{shapes.geometric, arrows}
\tikzstyle{startstop} = [rectangle, rounded corners, minimum height=0.5cm,text centered, draw=black, fill=red!30]
\tikzstyle{io} = [trapezium, trapezium left angle=70, trapezium right angle=110, minimum height=0.8cm, text centered, draw=black, fill=blue!30]
\tikzstyle{process} = [rectangle, minimum width=1cm, minimum height=1cm, text centered, draw=black, fill=orange!30]
\tikzstyle{decision} = [diamond, minimum width=1cm, minimum height=1cm, text centered, draw=black, fill=green!30]
\tikzstyle{arrow} = [thick,->,>=stealth]    
\tikzstyle{line} = [thick,-,>=stealth] 

\begin{document}

\title{ARM Final Report}
\author{Fawwaz Abdullah (ffa20), Robert Buxton (rb419), \\Edward Hartley (ech120), Wojtek Sowinski (ws420) }

\maketitle

\section{Assembler implementation}

\subsection{Data Structures}

\begin{itemize}

    \item \textbf{Map} (\texttt{StringUintMap}) A map implemented using an
    red-black tree and hashing function to allow strings to be mapped to unsigned
    32 bit integers. This is used in two cases. Firstly to map branch tags to 
    memory locations and secondly to translate assembly inputs to their respective
    enum representations to be parsed. The root (a MapNode) and number of nodes is stored.
    
    \item \textbf{Tree Node} (\texttt{MapNode}) A node in the red-black tree that 
    stores the hash identifier of the node, the number of symbols with this hash, 
    a list of symbols (\_\_StringUintPair\_\_), the colour of the node which is used for balancing, the 
    parent node, and the left and right children.

    \item \textbf{Symbol Pair} (\texttt{\_\_StringUintPair\_\_}) A strut holding a
    string (identifier of the symbol) and a corresponding value (either an 
    address or enum value). 

    
    \item \textbf{Query Result} (\texttt{QueryResult}) A strut returned when searching the map;
    it holds a Boolean describing whether a result was found and has a field for storing that result.
    
\end{itemize}

\begin{minipage}{0.45\textwidth}
\subsection{Program Structure}

\begin{itemize}
    \item \texttt{parser.c} \\Collects the symbols in the first pass of the
    input data and resets the file to be reread for the second pass.
    \item \texttt{symbols.c} \\Contains the functions that create and interact with the
    symbol map used to map labels to memory addresses.
    \item \texttt{assemble.c} \\Initalises the maps used in the assembler. Then 
    passes over the file twice mapping labels to memory addresses and converting
    instructions into binary.
    \item \texttt{branch.c} \\Handles converting the branch instruction.
    \item \texttt{dataprocessing.c} \\Handles converting the data processing
    instructions.
    \item \texttt{multiply.c} \\Handles the multiply instructions.
    \item \texttt{singledatatransfer.c} \\Handles the single data transfer instructions.
\end{itemize}
\end{minipage}%
\hfill
\begin{minipage}{0.45\textwidth}

\begin{figure}[H]
\begin{tikzpicture}[node distance=2cm]
    \node (start) [scale=0.5, startstop, align=center] at (0,0) {Start};
    \node (init_map) [scale=0.5, process, align=center] at (2,0) {Initialise the translation map};
    \node (open_file) [scale=0.5, io, align=center] at (2,-0.75) {Open assembly file};
    \node (init_map2) [scale=0.5, process, align=center] at (2,-1.4) {Initialise the symbols map};
    \node (end_file?) [scale=0.5, decision, align=center] at (2,-2.5) {end of file?};
    \node (is_symbol) [scale=0.5, decision, align=center] at (4,-2.5) {line has \\ symbol?};
    \node (add_map) [scale=0.5, process, align=center] at (4,-3.75) {add to \\ symbol map};
    \node (get_line) [scale=0.5, io, align=center] at (2,-3.75) {get the \\ next line};
    \node (rewind) [scale=0.5, io, align=center] at (0,-2.5) {rewind assembly \\ file};
    \node (create_file) [scale=0.5, io, align=center] at (0,-3.75) {create and open \\ output binary file};
    \node (end_file?2) [scale=0.5, decision, align=center] at (2,-4.75) {end of file?};
    \node (symbol_type) [scale=0.5, decision, align=center] at (2,-6.25) {type of \\ symbol};
    \node (sdt) [scale=0.5, align=center, process] at (0,-7.5) {translate \\ single data \\ transfer };
    \node (mult) [scale=0.5, align=center, process] at (1.35,-7.5) {translate \\ multiply};
    \node (brch) [scale=0.5, align=center, process] at (2.65,-7.5) {translate \\ branch};
    \node (dp) [scale=0.5, align=center, process] at (4,-7.5) {translate \\ data process};
    \node (write_out) [scale=0.5, io, align=center] at (2,-8.25) {write to output line};
    \node (get_line2) [scale=0.5, io, align=center] at (0.25,-5.75) {get the \\ next line};
    \node (close) [scale=0.5, io, align=center] at (2,-9) {close input \\ and output \\file};
    \node (finish) [scale=0.5, startstop, align=center] at (2,-10) {finish};

    \draw [arrow] (start) -- (init_map);
    \draw [arrow] (init_map) -- (open_file);
    \draw [arrow] (open_file) -- (init_map2);
    \draw [arrow] (init_map2) -- (end_file?);
    \draw [arrow] (end_file?) -- node[scale=0.5, xshift = 0.2cm, yshift=0.3cm] {yes} (rewind);
    \draw [arrow] (end_file?) -- node[scale=0.5, xshift = -0.2cm, yshift=0.3cm] {no} (is_symbol);
    \draw [arrow] (is_symbol) -- node[scale=0.5, xshift = -0.5cm] {yes} (add_map);
    \draw [arrow] (is_symbol) -- node[scale=0.5, xshift = -0.5cm] {no} (get_line);
    \draw [arrow] (add_map) -- (get_line);
    \draw [arrow] (get_line) -- (end_file?);
    \draw [arrow] (rewind) -- (create_file);
    \draw [arrow] (create_file) -- (0,-4.75) -- (end_file?2);
    \draw [arrow] (end_file?2) -- node[scale=0.5, xshift = -0.5cm, yshift=0.3cm] {no} (symbol_type);
    \draw [arrow] (symbol_type) -| node[scale=0.5, yshift = -1.5cm, xshift = -0.5cm] {SDT} (sdt);
    \draw [arrow] (symbol_type) -| node[scale=0.5, yshift = -1.5cm, xshift = -0.75cm] {MULT} (mult);
    \draw [arrow] (symbol_type) -| node[scale=0.5, yshift = -1.5cm, xshift = -0.75cm] {BRCH} (brch);
    \draw [arrow] (symbol_type) -| node[scale=0.5, yshift = -1.5cm, xshift = -0.5cm] {DP} (dp);
    \draw [arrow] (sdt) -- (write_out);
    \draw [arrow] (mult) -- (write_out);
    \draw [arrow] (brch) -- (write_out);
    \draw [arrow] (dp) -- (write_out);
    \draw [arrow] (write_out) -- (-0.6,-8.25) -- (-0.6,-5.75) -- (get_line2);
    \draw [arrow] (get_line2) -- (1,-5.75) -- (end_file?2);
    \draw [arrow] (end_file?2) -- node[scale=0.5, xshift = -0.5cm, yshift=0.3cm] {yes}
     (4.75,-4.75) -- (4.75,-9) -- (close);
    \draw [arrow] (close) -- (finish);
\end{tikzpicture}
\caption{A flowchart demonstrating program flow in assembler.c.}
\end{figure}
\end{minipage}

\section{Extension: Rubik's Cube solver}
\subsection{Description} 
Our group chose to build a Rubik's cube solving robot as our extension. The robot
would be able to solve a scrambled Rubik's cube. The robot can solve a 3 $\times$ 3 
cube in under \textcolor{red}{insert here} seconds. To complete the project we split the team 
into two sections with Robert working on the physical side of the project, designing 
and building the robot and Fawwaz, Edward and Wojtek working on the algorithm behind 
solving the cube.

\subsection{The Machine}

\subsubsection{Design} 

We decided to build the robot using primarily VEX Robotics parts we already owned which helped
reduce the cost of the robot significantly. The machine uses an ARM Cortex-A9 with 
128 MB of RAM and 6 motors with built in encoders to rotate and track the
positions of the 6 faces of the Rubik's cube. The program takes the current cube state 
as an input, calculates a solution and then generates a list of rotations which are sent 
to the motors to be executed.
    

\begin{minipage}{0.45\textwidth}
\begin{figure}[H]
\centering
\includegraphics[scale=0.05]{main cad.jpg}
\caption{A CAD rendering of the machine created in Autodesk Fusion 360 created 
before building the robot.}
\end{figure}
\end{minipage}%
\hfill
\begin{minipage}{0.45\textwidth}
\begin{figure}[H]
\centering
\includegraphics[scale=0.11]{final machine.jpg}
\caption{The final finished machine}
\end{figure}    
\end{minipage}

\subsubsection{Building process} 

The machine was built over a few days using the facilities at the advanced 
hackspace in the White City campus to print custom 3D parts. We created a simple
aluminium frame to which we attached the 6 motors. We used a Markforged 
3D printer to create strengthened nylon parts that we used as intermediaries 
between the axels and the Rubik's cube centre pieces we rotate. It was important that 
they were very strong as the pieces undergo high stress when rotated in 
multiple directions, at short notice and at a high speed.
\subsubsection{Challenges} 

The main challenge we came across was making sure the motors didn't over or under 
rotate the faces. When they did it would cause catastrophic failure as the next 
cube face would not be able to rotate and the cube would explode into lots of small 
pieces. It was also quite difficult securing the cube in the middle of the machine 
as you had to be very precise and if the cube was not completely secured the cube 
would not rotate.

\subsubsection{Future improvements}

If we were to keep working on this project the main things we would focus 
on improving would be firstly the frame. Currently it is quite unstable and we 
could definitely rebuild it to be more sturdy. It would also be interesting to 
add a camera to the machine to detect the current robot state automatically rather 
than having to rely on user input. We also would like to replace the cube we currently 
use with another that is a bit more forgiving with a wider margin of error allowed
for the rotations.

\subsection{The solving algorithm}
\subsubsection{Data Structures}

\begin{itemize}

    \item \textbf{Cube Movement} (\texttt{Movement}) A struct holding the face to 
    be moved and the direction to be moved (clockwise, anti-clockwise or double).
    
    \item \textbf{Cube State} (\texttt{CubeState}) Holds the current state of the 
    faces of the cube as six two-dimensional arrays of Colours. It also contains 
    a history of all movements that have been applied to the cube and how many moves
    are in that list.

    \item \textbf{Unfolding Template} (\texttt{UnfoldTemplate}) These precomputed
    structures hold information describing how each face connects to its neighbouring
    edges with regards to their array represeantation. When a face of the cube is rotated, this
    information is used to rotate the neighbouring edges along with it.
    
\end{itemize}

\subsubsection{Program structure}

\begin{minipage}{0.45\textwidth}
    \begin{itemize}
        \item \texttt{solver.c} \\ Initialises the priority queue and hash tree then 
        evaluates and expands states from the priority queue until either there are no states 
        left in the queue or a solution has been found. This is an 
        implementation of an A* graph search.
        \item \texttt{cubestate.c} \\ Holds all the functions used to modify and interact 
        with cube states.
        \item \texttt{hashtree.c}\\  Contains an implementation for the red black tree we 
        use for storing which cube state hashes we have visited.
        \item \texttt{movequeue.c}\\ Contains an implementation for the priority queue we use 
        for deciding the next state to visit.
        \item \texttt{testcubestate.c}\\ Tests to make sure cube state functions 
        function as intended.
        \item \texttt{testmovequeue.c}\\ Tests to make sure the move priority queue 
        works correctly.
        \item \texttt{testsolver.c}\\ Tests to make sure the whole program is working as 
        intended.
    \end{itemize}
    \end{minipage}%
    \hfill
    \begin{minipage}{0.45\textwidth}
    
    \begin{figure}[H]
    \begin{tikzpicture}[node distance=2cm]
        \node (start) [scale=0.5, startstop, align=center] at (0,0) {Start};
        \node (starting_state) [scale=0.5, io, align=center] at (1.5,0) {Get the 
        starting \\ state of the cube};
        \node (init_main) [scale=0.5, process, align=center] at (3.5,0) {Initialise the\\ 
        priority queue \\ and hash tree};
        \node (check_empty) [scale=0.5, decision, align=center] at (3.5,-1.5)
        {Can fetch \\ from \\ queue?};
        \node (not_solved) [scale=0.5, io, align=center] at (1.5,-1.5) 
        {Solution could \\ not be found};
        \node (finish) [scale=0.5, startstop, align=center] at (0,-1.5) {Finish};
        \node (pop) [scale=0.5, process, align=center] at (3.5,-3) {Take and remove 
        \\ the highest priority \\ state from queue};
        \node (add_hash) [scale=0.5, process, align=center] at (3.5,-4)
        {Adds state to \\ visited hash tree};
        \node (check_solved) [scale=0.5, decision, align=center] at (3.5,-5.5)
        {Is the cube \\ in a solved \\ state?};
        \node (solved) [scale=0.5, io, align=center] at (1.5, -5.5) 
        {Return the \\ solution};
        \node (expand_move) [scale=0.5, process, align=center] at (3.5,-7) 
        {Add all possible \\ moves\\ to a sub queue };
        \node (sub_queue_empty?) [scale=0.5, decision, align=center] at (3.5,-8.5) 
        {is sub \\ queue  \\ empty?};
        \node (take_move) [scale=0.5, process, align=center] at (3.5,-10) 
        {Take move \\ from queue \\ and apply to \\ parent state};
        \node (move_in_queue?) [scale=0.5, decision, align=center] at (3.5,-11.75) 
        {new state \\in visted hash \\ tree already?};
        \node (in_main_queue?) [scale=0.5, decision, align=center] at (3.5,-14) 
        {new state \\ in main\\ queue already?};
        \node (update_cost) [scale=0.5, process, align=center] at (1.5,-14) 
        {updated cost \\ in queue \\ if lower};
        \node (add_to_queue) [scale=0.5, process, align=center] at (5.5,-14) 
        {calculate cost \\and add \\ to queue};



        \draw [arrow] (start) -- (starting_state);
        \draw [arrow] (starting_state) -- (init_main);
        \draw [arrow] (init_main) -- (check_empty);
        \draw [arrow] (check_empty) -- node[scale=0.5, yshift=0.3cm] {no} (not_solved);
        \draw [arrow] (not_solved) -- (finish);
        \draw [arrow] (check_empty) -- node[scale=0.5, xshift=0.5cm] {yes} (pop);
        \draw [arrow] (pop) -- (add_hash);
        \draw [arrow] (add_hash) -- (check_solved);
        \draw [arrow] (check_solved) -- node[scale=0.5, yshift=0.3cm] {yes} (solved);
        \draw [arrow] (solved) -| (finish);
        \draw [arrow] (check_solved) -- node[scale=0.5, xshift=0.5cm] {no} (expand_move);
        \draw [arrow] (expand_move) -- (sub_queue_empty?);
        \draw [arrow] (sub_queue_empty?) -- node[scale=0.5, yshift=0.3cm] {yes} (5.5,-8.5) -- (5.5,-1.5) -- (check_empty);
        \draw [arrow] (sub_queue_empty?) -- node[scale=0.5, xshift=0.5cm] {no} (take_move);
        \draw [arrow] (take_move) -- (move_in_queue?);
        \draw [arrow] (move_in_queue?) -- node[scale=0.5, yshift=0.3cm] {yes} (1.5,-11.75) -- (1.5,-8.5) -- (sub_queue_empty?);
        \draw [arrow] (move_in_queue?) -- node[scale=0.5, xshift=0.5cm] {no} (in_main_queue?);
        \draw [arrow] (in_main_queue?) -- node[scale=0.5, yshift=0.3cm] {yes} (update_cost);
        \draw [arrow] (update_cost) -- (1.5,-11.75);
        \draw [arrow] (in_main_queue?) -- node[scale=0.5, yshift=0.3cm] {no} (add_to_queue);
        \draw [arrow] (add_to_queue) -- (5.5,-10) -- (sub_queue_empty?);

    \end{tikzpicture}
    \caption{A flowchart demonstrating program flow in solver.c.}
    \end{figure}
\end{minipage}

\subsection{Challenges and Alternative Algorithms}

Our Rubik's cube solver uses the A* path finding algorithm to find the shortest path
from the cube's inintial state to a solved cube. When we first implemented this, 
the algorithm's memory usage presented a major challenge. <<<TODO: SUMMERISE HOW MUCH RAM
THE INITIAL DESIGN USED>>>

One way we remedied this issue is by testing a variety of heuristics in an attemp to 
increase the likelihood of the A* algorithm finding the solution early. We also attempted
the following alternative algorithms:
\begin{itemize}
    \item \texttt{Kociemba's algorithm} \\ This algorithm created by Herbert Kociemba
    is a two-phase approach. In the first phase, a searching algorithm (such as A*)
    is used to find a path from the initial state to a subgroup of states referred to as G1.
    This subgroup is characterised by the fact that, once a cube is in G1, a solution can 
    be obtained using only 10 different moves as opposed to the usual 18. This speeds up 
    the second phase which is finding a path from G1 to a solved state.
    \item \texttt{Iterative Deepening A* (IDA*)} \\ This is a variant of the A* algorithm
    which uses a stack instead of a queue. It starts with an expected upper bound on
    the length of the solution, searches for solutions of length up to that bound in a
    depth-first fashion and, if no solution is found, the upper bound is increased.
    Many paths are explored multiple times which makes the algorithm slower but the use
    of a stack and the depth-first nature of the search makes it more memory efficient than A*.
\end{itemize}

The use of Kociemba's algorithm allowed us to solve more scrambled cubes more reliably but 
it also resulted in solutions which took more moves than necessary. Due to time constraints,
we weren't able to fully implement IDA*. Were we able to do that, the next step would have been 
to combine IDA* with Kociemba's two-phase approach.

\subsection{Testing and Debugging}

\subsubsection{Test Suite}

All testing for this extension was handled using a unit testing library (created ourselves, found in \texttt{[root]/extension/testsuite}).

The code was tested in parts, with behaviour mimicking the behavior of such unit testing libraries as \texttt{JUnit}, where a test file comprises of tester functions (a \texttt{void} function that takes no parameters), and an array of tagged function pointers to those functions to give friendly names in the output log for each test function.

The main function in a test file effectively iterates through all the tagged functions and runs them.
If a test function fails (i.e. an ``assertion" fails), the test function terminates and the next test function is executed.
A \texttt{setjmp} / \texttt{longjmp} pair was used to provide this functionality, in order to avoid using C's default \texttt{assert} function.

\subsubsection{Debugging}

GDB was used in order to help track down infinite loops and errant logic errors in our code, and Valgrind was used to help point out where memory was leaking, as the program deals with a lot of recursive data structures in the form of the \texttt{HashTree} type (used for backing the solver and the move queue).

\end{document}