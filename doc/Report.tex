\documentclass[8pt]{article}

\usepackage{fullpage}
\usepackage{tikz}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{float}
\usepackage{wrapfig}
\usepackage{titlesec}
\setcounter{secnumdepth}{4}
\graphicspath{ {./pictures/} }
\usepackage[a4paper,bindingoffset=0.2in,%
            left=0.75in,right=1in,top=1in,bottom=1in,%
            footskip=.25in]{geometry}
\usetikzlibrary{shapes.geometric, arrows}
\tikzstyle{startstop} = [rectangle, rounded corners, minimum height=0.5cm,text centered, draw=black, fill=red!30]
\tikzstyle{io} = [trapezium, trapezium left angle=70, trapezium right angle=110, minimum height=0.8cm, text centered, draw=black, fill=blue!30]
\tikzstyle{process} = [rectangle, minimum width=1cm, minimum height=1cm, text centered, draw=black, fill=orange!30]
\tikzstyle{decision} = [diamond, minimum width=1cm, minimum height=1cm, text centered, draw=black, fill=green!30]
\tikzstyle{arrow} = [thick,->,>=stealth]    
\tikzstyle{line} = [thick,-,>=stealth] 

\begin{document}

\title{ARM Final Report}
\author{Fawwaz Abdullah (ffa20), Robert Buxton (rb419), \\Edward Hartley (ech120), Wojtek Sowinski (ws420) }

\maketitle

\section{Assembler implementation}

\subsection{Data Structures}

\begin{itemize}

    \item \textbf{Map} (\texttt{StringUintMap}) A map implemented using an
    red-black tree and hashing function to allow strings to be mapped to unsigned
    32 bit intergers. This is used in two cases. Firstly to map branch tags to 
    memory locations and secondly to translate assembly inputs to their respective
    enum representations to be parsed. The root (a MapNode) and number of nodes is stored.
    
    \item \textbf{Tree Node} (\texttt{MapNode}) A node in the red-black tree that 
    stores the hash identifier of the node, the number of symbols with this hash, 
    a list of symbols (\_\_StringUintPair\_\_), the colour of the node which is used for balancing, the 
    parent node, and the left and right children.

    \item \textbf{Symbol Pair} (\texttt{\_\_StringUintPair\_\_}) a strut holding a
    string (identifier of the symbol) and a corresponding value (either an 
    address or enum value). 

    
    \item \textbf{Query Result} (\texttt{QueryResult}) a strut returned when searching the map
    holding the if a result was found and what it is if it was.
    
\end{itemize}

\begin{minipage}{0.45\textwidth}
\subsection{Program Structure}

\begin{itemize}
    \item \texttt{parser.c} \\Contains the function that collects the symbols in the first pass of the
    input data and resets the file to be reread for the second pass
    \item \texttt{symbols.c} \\Contains the functions that create and interact with the
    symbol map used to map labels to memory addresses.
    \item \texttt{assemble.c} \\Initalises the maps used in the assembler. Then 
    passes over the file twice mapping labels to memory addresses and converting
    instructions into binary.
    \item \texttt{branch.c} \\Handles converting the branch instruction
    \item \texttt{dataprocessing.c} \\Handles converting the data processing
    instructions
    \item \texttt{multiply.c} \\Handles the multiply instructions
    \item \texttt{singledatatransfer.c} \\Handles the single data transfer instructions
\end{itemize}
\end{minipage}%
\hfill
\begin{minipage}{0.45\textwidth}

\begin{figure}[H]
\begin{tikzpicture}[node distance=2cm]
    \node (start) [scale=0.5, startstop, align=center] at (0,0) {Start};
    \node (init_map) [scale=0.5, process, align=center] at (2,0) {Initialise the translation map};
    \node (open_file) [scale=0.5, io, align=center] at (2,-0.75) {Open assembly file};
    \node (init_map2) [scale=0.5, process, align=center] at (2,-1.4) {Initialise the symbols map};
    \node (end_file?) [scale=0.5, decision, align=center] at (2,-2.5) {end of file?};
    \node (is_symbol) [scale=0.5, decision, align=center] at (4,-2.5) {line has \\ symbol?};
    \node (add_map) [scale=0.5, process, align=center] at (4,-3.75) {add to \\ symbol map};
    \node (get_line) [scale=0.5, io, align=center] at (2,-3.75) {get the \\ next line};
    \node (rewind) [scale=0.5, io, align=center] at (0,-2.5) {rewind assembly \\ file};
    \node (create_file) [scale=0.5, io, align=center] at (0,-3.75) {create and open \\ output binary file};
    \node (end_file?2) [scale=0.5, decision, align=center] at (2,-4.75) {end of file?};
    \node (symbol_type) [scale=0.5, decision, align=center] at (2,-6.25) {type of \\ symbol};
    \node (sdt) [scale=0.5, align=center, process] at (0,-7.5) {translate \\ single data \\ transfer };
    \node (mult) [scale=0.5, align=center, process] at (1.35,-7.5) {translate \\ multiply};
    \node (brch) [scale=0.5, align=center, process] at (2.65,-7.5) {translate \\ branch};
    \node (dp) [scale=0.5, align=center, process] at (4,-7.5) {translate \\ data process};
    \node (write_out) [scale=0.5, io, align=center] at (2,-8.25) {write to output line};
    \node (get_line2) [scale=0.5, io, align=center] at (0.25,-5.75) {get the \\ next line};
    \node (close) [scale=0.5, io, align=center] at (2,-9) {close input \\ and output \\file};
    \node (finish) [scale=0.5, startstop, align=center] at (2,-10) {finish};

    \draw [arrow] (start) -- (init_map);
    \draw [arrow] (init_map) -- (open_file);
    \draw [arrow] (open_file) -- (init_map2);
    \draw [arrow] (init_map2) -- (end_file?);
    \draw [arrow] (end_file?) -- node[scale=0.5, xshift = 0.2cm, yshift=0.3cm] {yes} (rewind);
    \draw [arrow] (end_file?) -- node[scale=0.5, xshift = -0.2cm, yshift=0.3cm] {no} (is_symbol);
    \draw [arrow] (is_symbol) -- node[scale=0.5, xshift = -0.5cm] {yes} (add_map);
    \draw [arrow] (is_symbol) -- node[scale=0.5, xshift = -0.5cm] {no} (get_line);
    \draw [arrow] (add_map) -- (get_line);
    \draw [arrow] (get_line) -- (end_file?);
    \draw [arrow] (rewind) -- (create_file);
    \draw [arrow] (create_file) -- (0,-4.75) -- (end_file?2);
    \draw [arrow] (end_file?2) -- node[scale=0.5, xshift = -0.5cm, yshift=0.3cm] {no} (symbol_type);
    \draw [arrow] (symbol_type) -| node[scale=0.5, yshift = -1.5cm, xshift = -0.5cm] {SDT} (sdt);
    \draw [arrow] (symbol_type) -| node[scale=0.5, yshift = -1.5cm, xshift = -0.75cm] {MULT} (mult);
    \draw [arrow] (symbol_type) -| node[scale=0.5, yshift = -1.5cm, xshift = -0.75cm] {BRCH} (brch);
    \draw [arrow] (symbol_type) -| node[scale=0.5, yshift = -1.5cm, xshift = -0.5cm] {DP} (dp);
    \draw [arrow] (sdt) -- (write_out);
    \draw [arrow] (mult) -- (write_out);
    \draw [arrow] (brch) -- (write_out);
    \draw [arrow] (dp) -- (write_out);
    \draw [arrow] (write_out) -- (-0.6,-8.25) -- (-0.6,-5.75) -- (get_line2);
    \draw [arrow] (get_line2) -- (1,-5.75) -- (end_file?2);
    \draw [arrow] (end_file?2) -- node[scale=0.5, xshift = -0.5cm, yshift=0.3cm] {yes}
     (4.75,-4.75) -- (4.75,-9) -- (close);
    \draw [arrow] (close) -- (finish);
\end{tikzpicture}
\caption{A flowchart demonstrating program flow in assembler.c.}
\end{figure}
\end{minipage}

\section{Extension: Rubik's Cube solver}
\subsection{Description} 
Our group chose to build a Rubik's cube solving robot as our extension. The robot
would be able to solve a scrambled Rubik's cube. The robot can solve a 3 $\times$ 3 
cube in under \textcolor{red}{insert here} seconds. To complete the project we split the team 
into two sections with Robert working on the physical side of the project, designing 
and building the robot and Fawwaz, Edward and Wojtek working on the algorithm behind 
solving the cube.

\subsection{The Machine}

\subsubsection{Design} 

We decided to build the robot using primarily VEX Robotics parts we already owned which helped
reduce the cost of the robot significantly. The machine uses an ARM Cortex-A9 with 
128 MB of RAM and 6 motors with built in encoders to rotate and track the
positions of the 6 faces of the Rubik's cube. The program takes the current cube state 
as an input, calculated a solution then generates a list of rotations which are sent 
to the motors to be executed.
    

\begin{minipage}{0.45\textwidth}
\begin{figure}[H]
\centering
\includegraphics[scale=0.05]{main cad.jpg}
\caption{A CAD rendering of the machine created in Autodesk Fusion 360 created 
before building the robot.}
\end{figure}
\end{minipage}%
\hfill
\begin{minipage}{0.45\textwidth}
\begin{figure}[H]
\centering
\includegraphics[scale=0.11]{final machine.jpg}
\caption{The final finished machine}
\end{figure}    
\end{minipage}

\subsubsection{Building process} 

The machine was built over a few days using the facilities at the advanced 
hackspace in the White City campus to print custom 3D parts. We created a simple
aluminium frame to which we attached the 6 motors. We used a Markforged 
3D printer to create strengthened nylon parts that we used as intermediaries 
between the axels and Rubik's cube centre pieces we rotate. It was important that 
they were very strong as the pieces undergo quite a bit of stress when rotated in 
multiple directions and short notice at a high speed.
\subsubsection{Challenges} 

The main challenge we came across was making sure the motors didn't over or under 
rotate the faces. When they did it would cause catastrophic failure as the next 
cube face would not be able to rotate and the cube would explode into lots of small 
pieces. It was also quite difficult securing the cube in the middle of the machine 
as you had to be very precise and if the cube was not completely secured the cube 
would not rotate.

\subsubsection{Future improvements}

If we were to keep working on this project the main things we would focus 
on improving would be firstly the frame. Currently it is quite unstable and we 
could definitely rebuild it to be more sturdy. It would also be interesting to 
add a camera to the machine to detect the current robot state automatically rather 
than having to rely on user input. We also would like to replace the cube we currently 
use with another that is a bit more forgiving with the minimum angle required to 
rotate

\subsection{The solving algorithm}
\subsubsection{Data Structures}

\begin{itemize}

    \item \textbf{Cube Movement} (\texttt{Movement}) A struct holding the face to 
    be moved and the direction to be moved (clockwise or anti-clockwise)
    
    \item \textbf{Cube State} (\texttt{CubeState}) Holds the current face state 
    how much of the history has been filled and list of all movements that have 
    been applied to the cube.

    \item \textbf{Unfolding Template} (\texttt{UnfoldTemplate}) A template describing 
    how each face connects to it's neighbours  \textcolor{red}{I don't really 
    understand this can someone else fill this in}
    
\end{itemize}

\subsubsection{Program structure}

\begin{minipage}{0.45\textwidth}
    \begin{itemize}
        \item \texttt{solver.c} \\ Initialises the priority queue and hash tree then 
        evaluates states from the priority queue until either there are no states 
        left in the queue or if the loop exceeds a certain amount of states. This is an 
        implementation of A* graph search.
        \item \texttt{cubestate.c} \\ Holds all the function used to modify and interact 
        with cube states.
        \item \texttt{hashtree.c}\\  All the functions used in the red black tree we 
        use for hashing.
        \item \texttt{movequeue.c}\\ All the functions used in the priority queue we use 
        for deciding the next state to visit.
        \item \texttt{testcubestate.c}\\ Tests to make sure cube state functions 
        function as intended.
        \item \texttt{testmovequeue.c}\\ Tests to make sure the move priority queue 
        works correctly.
        \item \texttt{testsolver.c}\\ Tests to make sure the whole program is working as 
        intended.
    \end{itemize}
    \end{minipage}%
    \hfill
    \begin{minipage}{0.45\textwidth}
    
    \begin{figure}[H]
    \begin{tikzpicture}[node distance=2cm]
        \node (start) [scale=0.5, startstop, align=center] at (0,0) {Start};
        \node (starting_state) [scale=0.5, io, align=center] at (1.5,0) {Get the 
        starting \\ state of the cube};
        \node (init_main) [scale=0.5, process, align=center] at (3.5,0) {Initialise the\\ 
        priority queue \\ and hash tree};
        \node (check_empty) [scale=0.5, decision, align=center] at (3.5,-1.5)
        {Can fetch \\ from \\ queue?};
        \node (not_solved) [scale=0.5, io, align=center] at (1.5,-1.5) 
        {Solution could \\ not be found};
        \node (finish) [scale=0.5, startstop, align=center] at (0,-1.5) {Finish};
        \node (pop) [scale=0.5, process, align=center] at (3.5,-3) {Take and remove 
        \\ the highest priority \\ state from queue};
        \node (add_hash) [scale=0.5, process, align=center] at (3.5,-4)
        {Adds state to \\ visited hash tree};
        \node (check_solved) [scale=0.5, decision, align=center] at (3.5,-5.5)
        {Is the cube \\ in a solved \\ state?};
        \node (solved) [scale=0.5, io, align=center] at (1.5, -5.5) 
        {Return the \\ solution};
        \node (expand_move) [scale=0.5, process, align=center] at (3.5,-7) 
        {Add all possible \\ moves\\ to a sub queue };
        \node (sub_queue_empty?) [scale=0.5, decision, align=center] at (3.5,-8.5) 
        {is sub \\ queue  \\ empty?};
        \node (take_move) [scale=0.5, process, align=center] at (3.5,-10) 
        {Take move \\ from queue \\ and apply to \\ parent state};
        \node (move_in_queue?) [scale=0.5, decision, align=center] at (3.5,-11.75) 
        {new state \\in visted hash \\ tree already?};
        \node (in_main_queue?) [scale=0.5, decision, align=center] at (3.5,-14) 
        {new state \\ in main\\ queue already?};
        \node (update_cost) [scale=0.5, process, align=center] at (1.5,-14) 
        {updated cost \\ in queue \\ if lower};
        \node (add_to_queue) [scale=0.5, process, align=center] at (5.5,-14) 
        {calculate cost \\and add \\ to queue};



        \draw [arrow] (start) -- (starting_state);
        \draw [arrow] (starting_state) -- (init_main);
        \draw [arrow] (init_main) -- (check_empty);
        \draw [arrow] (check_empty) -- node[scale=0.5, yshift=0.3cm] {no} (not_solved);
        \draw [arrow] (not_solved) -- (finish);
        \draw [arrow] (check_empty) -- node[scale=0.5, xshift=0.5cm] {yes} (pop);
        \draw [arrow] (pop) -- (add_hash);
        \draw [arrow] (add_hash) -- (check_solved);
        \draw [arrow] (check_solved) -- node[scale=0.5, yshift=0.3cm] {yes} (solved);
        \draw [arrow] (solved) -| (finish);
        \draw [arrow] (check_solved) -- node[scale=0.5, xshift=0.5cm] {no} (expand_move);
        \draw [arrow] (expand_move) -- (sub_queue_empty?);
        \draw [arrow] (sub_queue_empty?) -- node[scale=0.5, yshift=0.3cm] {yes} (5.5,-8.5) -- (5.5,-1.5) -- (check_empty);
        \draw [arrow] (sub_queue_empty?) -- node[scale=0.5, xshift=0.5cm] {no} (take_move);
        \draw [arrow] (take_move) -- (move_in_queue?);
        \draw [arrow] (move_in_queue?) -- node[scale=0.5, yshift=0.3cm] {yes} (1.5,-11.75) -- (1.5,-8.5) -- (sub_queue_empty?);
        \draw [arrow] (in_main_queue?) -- node[scale=0.5, yshift=0.3cm] {yes} (update_cost);
        \draw [arrow] (update_cost) -- (1.5,-11.75);
        \draw [arrow] (in_main_queue?) -- node[scale=0.5, yshift=0.3cm] {no} (add_to_queue);
        \draw [arrow] (add_to_queue) -- (5.5,-10) -- (sub_queue_empty?);

    \end{tikzpicture}
    \caption{A flowchart demonstrating program flow in solver.c.}
    \end{figure}
\end{minipage}

\subsection{Testing and Debugging}

\subsubsection{Test Suite}

All testing for this extension was handled using a unit testing library (created ourselves, found in \texttt{[root]/extension/testsuite}).

The code was tested in parts, with behaviour mimicking the behavior of such unit testing libraries as \texttt{JUnit}, where a test file comprises of tester functions (a \texttt{void} function that takes no parameters), and an array of tagged function pointers to those functions to give friendly names in the output log for each test function.

The main function in a test file effectively iterates through all the tagged functions and runs them.
If a test function fails (i.e. an ``assertion" fails), the test function terminates and the next test function is executed.
A \texttt{setjmp} / \texttt{longjmp} pair was used to provide this functionality, in order to avoid using C's default \texttt{assert} function.

\subsubsection{Debugging}

GDB was used in order to help track down infinite loops and errant logic errors in our code, and Valgrind was used to help point out where memory was leaking, as the program deals with a lot of recursive data structures in the form of the \texttt{HashTree} type (used for backing the solver and the move queue).

\end{document}